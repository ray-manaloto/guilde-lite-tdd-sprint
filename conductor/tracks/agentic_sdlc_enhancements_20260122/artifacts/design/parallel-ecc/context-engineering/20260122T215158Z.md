# Relevant Items

- **Memory persistence hooks**: `hooks/memory-persistence/session-start.sh`, `session-end.sh`, and `pre-compact.sh` wired in `hooks/hooks.json` for `SessionStart`, `Stop`, and `PreCompact` events. These create/update per-day session files in `~/.claude/sessions` and log compaction events.  
- **Strategic compaction**: `hooks/strategic-compact/suggest-compact.sh` auto-suggests `/compact` based on tool-call count.  
- **Continuous learning hooks**: `skills/continuous-learning/` plus `Stop` hook calls `./skills/continuous-learning/evaluate-session.sh` to extract patterns at session end.  
- **Context files**: `contexts/` and example `CLAUDE.md` (under `examples/`) align with context-engineering patterns in the research digest.  
- **Rules/commands**: `/checkpoint`, `/verify`, `/learn`, and verification skills support structured state capture and eval loops.

# Recommended Adoption

1. **Adopt memory persistence hooks** (SessionStart/Stop/PreCompact) as the backbone of context continuity. This maps directly to the “structured note-taking / persistent scratchpad” strategy highlighted in the research digest and enables long-horizon work without overloading the live context window.  
2. **Adopt strategic compaction suggestions** to control when compaction happens (post-milestones rather than mid-task). This aligns with “context engineering” guidance to compact at logical boundaries.  
3. **Adopt continuous-learning extraction** selectively (post-session) to build durable skills from repeated patterns, but gate it with human review to avoid knowledge rot.  
4. **Adopt a lightweight `CLAUDE.md`-style project context file** (even for Codex) to centralize project invariants, commands, and key decisions.

# Adaptation Notes (for Codex Sessions)

- **Session persistence**:  
  - Port the shell scripts to your Codex session hooks (or external wrapper scripts) to keep the same `~/.claude/sessions` scratchpad pattern.  
  - Standardize the session file template as the “handoff artifact” for Codex restarts.  
- **Compaction flow**:  
  - If Codex lacks native `/compact`, keep the **manual compaction suggestion** and trigger a “summarize to file” step instead (append to session file).  
- **Memory hooks**:  
  - Use a single “memory store” file (e.g., `codex-memory.md`) and have Codex load it at session start. This mirrors the repository’s `SessionStart` and `SessionEnd` scripts.  
- **Context file**:  
  - Maintain `CLAUDE.md`-equivalent for Codex (e.g., `CODEX.md`) and inject it at session start.  
- **Agentic workflows**:  
  - Keep the repo’s orchestration pattern (planner/reviewer) but run as separate Codex sessions/worktrees if needed, matching the research digest’s parallel agent guidance.

# Risks/Dependencies

- **Hook execution environment**: Codex must support lifecycle hooks or external wrapper scripts; otherwise the workflow relies on manual steps.  
- **Knowledge rot**: Continuous-learning auto-extraction can encode outdated assumptions without review.  
- **Context bloat**: Session files can grow too large; needs periodic pruning or summaries.  
- **OS portability**: `session-end.sh` uses `sed -i ''` (macOS); requires GNU sed compatibility on Linux.

# Open Questions

- What Codex equivalents exist for Claude’s `SessionStart`, `Stop`, and `PreCompact` hooks, and how reliable are they in long-running sessions?  
- How should we curate/expire learned skills to avoid stale guidance over time?  
- Do we want a single persistent “memory file” per project or a rolling daily log (as in this repo)?  
- What is the desired cadence for compaction and summarization in Codex—per milestone, per day, or per session?