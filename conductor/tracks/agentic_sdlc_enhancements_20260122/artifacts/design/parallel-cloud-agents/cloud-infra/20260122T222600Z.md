## Design Decisions
- **Execution model**: Use AWS Step Functions as the “cloud subagent supervisor” for parallel/arbiter patterns. Each subagent runs in **Lambda** for short tasks; **Fargate** for heavy/long tasks with explicit timeouts.  
- **Isolation & security**: Place compute in **private subnets** with **VPC endpoints** (S3/Secrets Manager). Enforce **least-privilege IAM** per agent role. Set **reserved concurrency** per agent to prevent runaway costs.  
- **Scheduling & throttling**: Event-driven triggers from Conductor state changes (e.g., `plan.md` ready) via **EventBridge** → Step Functions. Use **SQS** for backpressure; concurrency caps in Step Functions + Lambda.  
- **Cost controls**: Tag all resources by `agent`, `repo`, `run_id`; apply **AWS Budgets + alerts** and per-agent **cost anomaly detection**. Prefer pay-per-use (Lambda/Fargate Spot for non-critical).  
- **Observability**: CloudWatch logs + X-Ray/OTel traces. Track token usage and loop detection metrics.  
- **Secrets**: Use **Secrets Manager** with rotation; deny inline creds.  
- **Artifact exchange**: Subagents read minimal context (Conductor artifacts only) and return **diff/patch** outputs stored in S3; Step Functions writes back to Conductor artifacts via a merge step.

## Deliverables
- **spec.md additions** (cloud section): agent execution model, isolation requirements, scheduling triggers, cost controls, artifact I/O contract.
- **plan.md entries**: AWS resources (Step Functions, Lambda/Fargate, EventBridge, SQS, VPC endpoints), IAM policies, tagging/budget strategy, observability setup.
- **Infra templates**: CDK/Terraform modules for Step Functions, SQS queues, Lambda/Fargate tasks, VPC endpoints, IAM roles, CloudWatch alarms/budgets.

## Gates
- **Security gate**: IAM least-privilege review + no public egress unless explicitly allowed.
- **Cost gate**: Budget/alert in place; concurrency caps configured; tag enforcement.
- **Observability gate**: X-Ray/OTel tracing enabled; token usage metrics emitted.
- **Artifact gate**: Subagents output only diffs/patches; merge step validated.

## Risks/Dependencies
- **Dependency on Conductor artifacts**: Requires consistent spec/plan structure to minimize context passed to agents.
- **Latency**: Step Functions + Lambda overhead may affect interactive loops.
- **Cost drift**: Parallel agents can spike usage without strict concurrency limits.
- **VPC constraints**: Private subnet + endpoints add complexity and costs.

## Open Questions
- Which tasks require Fargate vs. Lambda (time/memory thresholds)?
- Do we need cross-account isolation per repo/team?
- Preferred IaC (CDK vs Terraform) and existing tagging/budget policies?
- Any compliance requirements for data egress or storage of agent outputs?