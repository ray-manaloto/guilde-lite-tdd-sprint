# Design Decisions

- **Tiered context model (Phase 2):**
  - **Core Tier (always loaded):** `CLAUDE.md`, `docs/context/CONTEXT_CORE.md`, `docs/context/ROLES.md`, `docs/context/GUARDRAILS.md`. Includes role boundaries, tool policies, and required hooks.
  - **Task Tier (per-track):** `docs/tracks/<track-id>/SPEC.md`, `PLAN.md`, `RISKS.md`, `DECISIONS.md`. Only the active track is loaded to avoid bleed.
  - **Transient Tier (rolling window):** `artifacts/sessions/<session-id>/recent_diff.txt`, `artifacts/sessions/<session-id>/test_output.txt`, `artifacts/sessions/<session-id>/work_log.md`. Used for immediate execution context.
- **Deterministic compaction rules:**
  - **Trigger:** `PreCompact` hook fires when token budget > threshold or `Checkpoint` event runs.
  - **Inputs:** Transient Tier + Task Tier deltas since last checkpoint.
  - **Outputs (fixed paths):**
    - `docs/tracks/<track-id>/DECISIONS.md` (append-only, timestamped)
    - `docs/tracks/<track-id>/PLAN.md` (overwrite with normalized plan)
    - `docs/tracks/<track-id>/RISKS.md` (append/update with severity tags)
    - `docs/context/CONTEXT_CORE.md` (only if new global invariant identified)
  - **Format:** Structured bullet schema to keep compaction deterministic (e.g., `Decision:`, `Reason:`, `Impact:`).
- **Recovery flow (deterministic):**
  - **Step 1:** Load Core Tier files in fixed order.
  - **Step 2:** Load Task Tier based on `docs/tracks/ACTIVE_TRACK` pointer.
  - **Step 3:** Load last checkpoint metadata from `artifacts/checkpoints/<track-id>/latest.json`.
  - **Step 4:** Pull Transient Tier artifacts referenced in `latest.json`.
  - **Step 5:** Reconstruct state using `DECISIONS.md` + `PLAN.md`; ignore older transient history.
- **Guardrails & hooks:**
  - **PreToolUse:** enforce allowed tool list; block file writes outside `docs/` and `artifacts/`.
  - **PostToolUse:** log to `artifacts/sessions/<session-id>/work_log.md`.
  - **PreCompact:** execute compaction routine; refuse if schema violation.
  - **Evaluator loop:** run evaluator on `PLAN.md` and `SPEC.md` before major execution.

# Deliverables

- **Context tier spec:** `docs/context/CONTEXT_TIERS.md`
- **Compaction schema & hook contract:** `docs/context/COMPACTION_RULES.md`
- **Recovery flow runbook:** `docs/context/RECOVERY_FLOW.md`
- **Guardrails policy:** `docs/context/GUARDRAILS.md`
- **Artifact layout map:** `docs/context/ARTIFACT_PATHS.md`
- **Hook definitions (shell/SDK):** `automation/hooks/precompact.sh`, `automation/hooks/pretooluse.py`, `automation/hooks/posttooluse.py`

# Gates

- **Compaction determinism gate:** Repeat compaction with same inputs → identical outputs (hash check).
- **Recovery replay gate:** Start new session using `latest.json` → restored plan matches `PLAN.md` checksum.
- **Guardrail enforcement gate:** Attempt forbidden path write → blocked and logged.
- **Evaluator gate:** `PLAN.md` must pass evaluator before execution tasks begin.

# Risks/Dependencies

- **Risk:** Compaction drift if schema is not enforced rigidly.
- **Risk:** Overwriting `PLAN.md` without capturing history → mitigated by append-only `DECISIONS.md`.
- **Dependency:** Hook infrastructure (PreToolUse/PostToolUse/PreCompact) must be available.
- **Dependency:** Stable artifact paths; any path change breaks deterministic recovery.

# Open Questions

- What token threshold should trigger `PreCompact` to balance stability vs. frequency?
- Should `CONTEXT_CORE.md` be writable by automation or only manual review?
- Do we need a separate `docs/context/INVARIANTS.md` to isolate global constraints from evolving core context?